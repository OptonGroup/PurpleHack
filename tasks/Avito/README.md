# Определение основного цвета товара на фотографии

## Введение

Данный проект решает задачу определения основного цвета товара по фотографии для платформы Avito. Разработанная модель машинного обучения классифицирует товары в 4 категориях (одежда для девочек, столы, стулья, сумки) по 18 возможным цветам. Решение основано на глубоком обучении с использованием предобученных моделей, что обеспечивает высокую точность классификации при сохранении хорошей производительности.

## Описание задачи

### Цель

Определить основной цвет товара на фотографии, выбрав один из 18 возможных цветов

### Категории товаров

- одежда для девочек
- столы
- стулья
- сумки

### Метрики оценки

- **Recall (macro)** - важно не пропустить товары нужного цвета
- **Precision (macro)** - важно уменьшить ложные срабатывания
- **Accuracy** - общая точность модели
- **F1 (macro)** - гармоническое среднее Precision и Recall

## Архитектура решения

### Обзор подхода

Для решения задачи был выбран подход глубокого обучения с использованием современной архитектуры компьютерного зрения. Основой решения стала предобученная модель BEiT v2 (Bidirectional Encoder representation from Image Transformers), адаптированная для задачи классификации цветов.

### Ключевые компоненты модели

1. **Backbone**: BEiT v2 Large с размером патча 16x16 и входным разрешением 224x224
2. **Учет категории товара**: Дополнительный embedding слой, кодирующий категорию товара
3. **Классификационная голова**: Полносвязанная нейронная сеть с активацией ReLU и dropout для регуляризации

## Предобработка данных

### Трансформации для обучения

```python
train_transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.RandomHorizontalFlip(p=0.5),
    transforms.RandomRotation(10, fill=0, interpolation=transforms.InterpolationMode.BILINEAR),
    transforms.ColorJitter(brightness=0.2, contrast=0.2, saturation=0.2, hue=0),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
])
```

### Трансформации для валидации и тестирования

```python
test_transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
])
```

## Обучение модели

### Параметры обучения

- **Планировщик скорости обучения**: CosineAnnealingLR с T_max=10
- **Функция потерь**: CrossEntropyLoss
- **Размер батча**: 32 для обучения, 64 для валидации и тестирования

## Инференс и предсказания

### Формат выходных данных

Для каждого изображения модель возвращает:

- Предсказанный основной цвет (`predict_color`)
- Вероятности для всех 18 цветов в формате JSON-строки (`predict_proba`)

### Пример вывода:

```
{
    "id": 36490520922,
    "category": "сумки",
    "predict_proba": {"bezhevyi": 0.01, "belyi": 0.8, "chernyi": 0.1, ...},
    "predict_color": "belyi"
}
```

### Оптимизация инференса

- Использование torch.jit для оптимизации модели
- Поддержка inference на GPU для ускорения предсказаний
- Настройка TensorRT/CUDA для максимизации производительности

## Результаты и анализ

### Метрики на валидационной выборке

_Примечание: конкретные значения будут получены после финальной оценки_

- Precision (macro): 0.7303
- Recall (macro): 0.7045
- F1 (macro): 0.7172
- Accuracy: 0.7978

### Производительность

Среднее время инференса: 62.51 мс  
Минимальное время: 61.76 мс  
Максимальное время: 63.37 мс  
95-й перцентиль: 63.16 мс  

## Анализ сложных случаев

### Типичные источники ошибок

1. **Многоцветные товары** - особенно в категории "сумки", где часто присутствует несколько цветов
2. **Освещение** - различное освещение на фотографиях может искажать восприятие цвета
3. **Фон товара** - в некоторых случаях фон может доминировать над цветом самого товара

## Использование решения

### Обучение модели

Для обучения модели используйте скрипт `train.ipynb`.

### Предсказания для целого набора данных

Для генерации предсказаний для тестового набора данных используйте скрипт `inference-to-create-submission.ipynb`.

### Предсказание для одного изображения

Для предсказания цвета одиночного изображения используйте функцию `predict_color` из скрипта `inference-for-one-imagee.ipynb`:
